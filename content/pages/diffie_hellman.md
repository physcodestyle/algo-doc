---
title: Протокол Диффи-Хеллмана
permalink: /algorythms/dh/index.html
---
### Область применения:
**Протокола Диффи-Хеллмана (DH)** - это метод безопасного обмена криптографическими ключами по общедоступному каналу. Это один из первых протоколов с открытым ключом, который изучался Ральфом Мерклем и назван в честь Уитфилда Диффи и Мартина Хеллмана. Поскольку основы криптографии с открытыми ключами были выдвинуты Уитфилдом Диффи и Мартином Хеллманом, а также независимо от них Ральфом Мерклом. Сегодня DH используется для многих приложений, таких как, например, Proton Mail, SSH, GPG и так далее.
### Идея/рисунки/анимация:
Необходимо отметить, что алгоритм Диффи - Хеллмана работает только на линиях связи, надёжно защищённых от модификации. Если бы он был применим на любых открытых каналах, то давно снял бы проблему распространения ключей и, возможно, заменил собой всю асимметричную криптографию. Однако, в тех случаях, когда в канале возможна модификация данных, появляется очевидная возможность вклинивания в процесс генерации ключей «злоумышленника-посредника» по той же самой схеме, что и для асимметричной криптографии.
Опишем ситуацию, есть два абонента, обоим абонентам известны некоторые два числа g и p, которые не являются секретными и могут быть известны также другим заинтересованным лицам. Для того, чтобы создать неизвестный более никому секретный ключ, оба абонента генерируют большие случайные числа: первый абонент — число a, второй абонент — число b. Затем первый абонент вычисляет значение A = g^a * (mod p) и пересылает его второму, а второй вычисляет B = g^b *n (mod p) и передаёт первому. Предполагается, что злоумышленник может получить оба этих значения, но не модифицировать их (то есть у него нет возможности вмешаться в процесс передачи). 
На втором этапе первый абонент на основе имеющегося у него a и полученного по сети B вычисляет значение B^a * (mod p) = g^ab * (mod p), а второй абонент на основе имеющегося у него b и полученного по сети A вычисляет значение A^b * (mod p) = g^ab * (mod p). Как нетрудно видеть, у обоих абонентов получилось одно и то же число: K = g^ab * (mod p). Его они и могут использовать в качестве секретного ключа, поскольку здесь злоумышленник встретится с практически неразрешимой (за разумное время) проблемой вычисления g^ab * (mod p) по перехваченным g^a * (mod p) и g^b * (mod p), если числа p,a,b выбраны достаточно большими.
***При работе алгоритма, каждая сторона:***
* Генерирует случайное натуральное число a — закрытый ключ;
* Совместно с удалённой стороной устанавливает открытые параметры p и g (обычно значения p и g генерируются на одной стороне и передаются другой), где p является случайным простым числом g является первообразным корнем по модулю p;
* Вычисляет открытый ключ A, используя преобразование над закрытым ключом A = g^a * (mod p);
* Обменивается открытыми ключами с удалённой стороной;
* Вычисляет общий секретный ключ K, используя открытый ключ удаленной стороны B и свой закрытый ключ a K = B^a * (mod p). Ключ получается равным с обоих сторон, потому что:
B^a * (mod p) = (g^b * (mod p))^a * (mod p) = g^ab * (mod p) = (g^a * (mod p))^b * (mod p) = A^b * (mod p).

В практических реализациях, для a и b используются числа порядка 10^100 и p порядка 10^300. Число g не обязано быть большим и обычно имеет значение в пределах первого десятка.

Отметим криптографическую стойкость алгоритма Диффи — Хеллмана (то есть сложность вычисления K=g^ab * (mod p) по известным p, g, A=g^a * (mod p) и B=g^b * (mod p), основана на предполагаемой сложности проблемы дискретного логарифмирования. Однако, хотя умение решать проблему дискретного логарифмирования позволит взломать алгоритм Диффи - Хеллмана, обратное утверждение до сих является открытым вопросом, т.е. эквивалентность этих проблем не доказана.

Алгоритм Диффи - Хеллмана также может быть использован при шифровании с открытым ключом. В этом случае общая схема остаётся аналогичной приведённой выше, но с небольшими отличиями. Абонент не передаёт значения p, g и A другому абоненту напрямую, а публикует их заранее в качестве своего открытого ключа. Второй абонент выполняет свою часть вычислений, после чего шифрует сообщение симметричным алгоритмом, используя K в качестве ключа, и передает шифротекст первому абоненту вместе со значением B. На практике алгоритм Диффи - Хеллмана таким образом не используется.

#### Получение ключа без передачи ключа:

Если имеется сообщество пользователей, каждый из пользователей может опубликовать открытый ключ X=g^x * (mod n) в общей базе данных. Если абонент хочет установить связь со вторым абонентам, первому абоненту надо получить открытый ключ второго абонента и сгенерировать их общий секретный ключ. Первый абонент может зашифровать сообщение сгенерированным секретным ключом и послать его второму абоненту, который извлечет открытый ключ первого абонента и найдет общий секретный ключ.
Каждая пара пользователей может использовать свой уникальный секретный ключ, не требуя обмена данными между пользователями. При этом все открытые ключи должны пройти проверку подлинности для того, чтобы исключить «человека посередине».
Использование алгоритма Диффи - Хеллмана не ограничивается двумя участниками. Он может быть применен на неограниченное количество пользователей. Рассмотрим ситуацию, когда три абонента вместе генерируют исходный ключ. В данном случае последовательность действий будет следующая:
**Все вычисления производятся по модулю p.**
* Стороны договариваются о параметрах алгоритма p и g;
* Стороны генерируют свои ключи — a, b и c соответственно;
* Первый абонент вычисляет g^a и посылает его второму абоненту;
* Второй абонент вычисляет (g^a)*b = g^ab и посылает его третьему абоненту;
* Третий абонент вычисляет (g^ab)*c = g^abc и получает тем самым общий секретный ключ;
* Второй абонент вычисляет g^b и посылает его третьему абоненту;
* Третий абонент вычисляет (g^b)c= g^bcи посылает его первому абоненту;
* Первый абонент вычисляет (g^bc)*a= g^bca = g^abc - общий секретный ключ;
* Третий абонент вычисляет g^c и посылает его первому абоненту;
* Первый абонент вычисляет (g^c)*a = gca и посылает его второму абоненту;
* Второй абонент вычисляет (g^ca)*b = g^cab = g^abc и также получает общий секретный ключ;

Если кто-то будет прослушивать канал связи, то он сможет увидеть g^a, g^b, g^c, g^ab, g^ca, и g^bca, но при этом не сможет воспроизвести g^abc используя любые комбинации этих чисел.

Для того чтобы данный алгоритм был эффективно применен для большой группы людей, необходимо соблюдение двух основных принципов:
* Передача ключа должна начинаться с «пустого» ключа g. Весь секрет состоит в повышении текущего значения показателя каждого участника один раз;
* Любое промежуточное значение может быть раскрыто публично, но окончательное значение представляет из себя секретный ключ, который никогда не должен быть публично раскрыт. Таким образом, каждый пользователь получает свою копию тайного ключа.

### Реализации на разных языках:
**java**
```sh
class DH_Endpoint():
def __init__(self, public_key1, public_key2, private_key):
self.public_key1 = public_key1 self.public_key2 = public_key2
self.private_key = private_key
self.full_key = None def generate_partial_key(self):
partial_key = self.public_key1 ** self.private_key
partial_key = partial_key % self.public_key2
return partial_key
def generate_full_key(self, partial_key_r):
full_key = partial_key_r ** self.private_key
full_key = full_key % self.public_key2
self.full_key = full_key
return full_key
def encrypt_message(self, message):
encrypted_message = ""
key = self.full_key
for c in message:
encrypted_message += chr(ord(c) + key)
return encrypted_message
def decrypt_message(self, encrypted_message):
decrypted_message = ""
key = self.full_key
for c in encrypted_message:
decrypted_message += chr(ord(c) — key)
return decrypted_message
message = "This is a very secret message!!!"
s_public = 197
s_private = 199
m_public = 151
m_private = 157
Sadat = DH_Endpoint(s_public, m_public, s_private)
Michael = DH_Endpoint(s_public, m_public, m_private)
s_partial = Sadat.generate_partial_key()
print(s_partial) # 147
m_partial = Michael.generate_partial_key()
print(m_partial) # 66
s_full = Sadat.generate_full_key(m_partial)
print(s_full) # 75
m_full=Michael.generate_full_key(s_partial)
print(m_full) # 75
m_encrypted = Michael.encrypt_message(message)
print(m_encrypted)
def decrypt_message(self, encrypted_message):
decrypted_message = ""
key = self.full_key
for c in encrypted_message:
decrypted_message += chr(ord(c) — key)
return decrypted_message
```
**Python**
***Основной принцип работы клиента и сервера такой:***
* При запуске клиент и сервер генерируют каждый свою пару ключей. 
* При подключении клиент посылает серверу свой открытый ключ.
* В ответ, сервер посылает клиенту открытый ключ сервера.
* Клиент посылает сообщение серверу, шифруя его своим закрытым ключом и открытым ключом сервера.
* Сервер принимает сообщение, расшифровывает его сначала своим закрытым ключом, а потом - открытым ключом клиента.
* Обратное сообщение посылается аналогично.

```sh
import socket
import pickle

HOST = '127.0.0.1'

PORT = 8080
sock = socket.socket()
sock.connect((HOST, PORT))

p, g, a = 7, 5, 3
A = g ** a % p

sock.send(pickle.dumps((p, g, A)))
```
```sh
import socket
import pickle

HOST = '127.0.0.1'
PORT = 8080

sock = socket.socket()
sock.bind((HOST, PORT))
sock.listen(1)
conn, addr = sock.accept()
msg = conn.recv(1024)
print(pickle.loads(msg))

conn.close()
```

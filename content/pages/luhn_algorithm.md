---
title: Алгоритм Луна
permalink: /algorythms/luhn_algorithm/index.html
---

### Область применения:

***Алгоритм Луна*** - алгоритм вычисления контрольной цифры номера пластиковой карты в соответствии со стандартом ISO/IEC 7812. Не является криптографическим средством, а предназначен в первую очередь для выявления ошибок, вызванных непреднамеренным искажением данных (например, при ручном вводе номера карты, при приёме данных о номере социального страхования по телефону). 
Позволяет лишь с некоторой степенью достоверности судить об отсутствии ошибок в блоке цифр, но не дает возможности нахождения и исправления обнаруженной неточности.

Алгоритм разработан сотрудником фирмы IBM Хансом Питером Луном, описан в США в 1954 году, патент на алгоритм получен в 1960 году.

**Наиболее распространённые применения алгоритма Луна:**
* Номера всех банковских карт;
* Номера некоторых дисконтных карт;
* Коды социального страхования;
* IMEI-коды;
* Расчёт контрольного знака единого 8-значного номера железнодорожного вагона на РЖД;
* Расчёт ICCID — уникальный серийный номер SIM-карты.

В настоящее время алгоритм является публичным достоянием.

### Идея/рисунки/анимация:

Для примера возьмем номер банковской карты. Начинаем слева с первой цифры последовательности и через одну цифру, используем такую технику только, если количество цифр в последовательности нечетное. Если же количество цифр четное, тогда, начиная со второй цифры последовательности через одну цифру, делается проверка: 
*если* 2x > 9, то из произведения вычитается 9, 
*иначе* произведение 2x оставляем без изменения. Где x — является текущей цифрой.

**Например:**

```sh
4  5  6  1     2  6  1  2     1  2  3  4     5  4  6  4
8     12       4     2        2     6        10    12
8     3        4     2        2     6        1     3
8  5  3  1     4  6  2  2     2  2  6  4     1  4  3  4
```

Затем все числа, полученные на предыдущем этапе, складываются.
8+5+3+1 + 4+6+2+2 + 2+2+6+4 + 1+4+3+4 = 57

Полученная сумма должна быть кратна 10. В примере выше исходная последовательность некорректна.
В примере: последняя цифра — контрольная. Для того, чтобы номер был верен в соответствии с алгоритмом Луна, контрольная цифра должна быть равна 7.

```sh
4  5  6  1     2  6  1  2     1  2  3  4     5  4  6  7
8     12       4     2        2     6        10    12
8     3        4     2        2     6        1     3
8  5  3  1     4  6  2  2     2  2  6  4     1  4  3  7
```

Тогда при суммировании мы получим корректное число:
8+5+3+1 + 4+6+2+2 + 2+2+6+4 + 1+4+3+7 = 60

***Ещё раз повторим последовательность алгоритма:***
1. Цифры проверяемой последовательности нумеруются справа налево.
2. Цифры, оказавшиеся на нечётных местах, остаются без изменений.
3. Цифры, стоящие на чётных местах, умножаются на 2.
4. Если в результате такого умножения возникает число больше 9, оно заменяется суммой цифр получившегося произведения — однозначным числом, то есть цифрой.
5. Все полученные в результате преобразования цифры складываются. Если сумма кратна 10, то исходные данные верны.
   
### Аналоги алгоритма:

* Алгоритм Верхоффа.

### Достоинства и недостатки алгоритма:

**Плюсы:**
* В силу простоты реализации алгоритм отнимает минимум вычислительных мощностей; 
* В ряде случаев при наличии навыка расчёт может быть произведён в уме; 
* Может быть полезен в обнаружении искажения одной цифры.

**Минусы:**
* Алгоритм Луна позволяет только выявить ошибки в блоках данных, и то не все. Но не исправит ошибки;
* Обнаруживаются практически все парные перестановки подряд идущих цифр (за исключением 09 ↔ 90);
* Не могут быть обнаружены некоторые искажения двух подряд идущих цифр, а именно 22 ↔ 55, 33 ↔ 66 и 44 ↔ 77; 
* Алгоритм не даёт информации о месте и характере возникшей ошибки;
* Алгоритм может применяться для последовательностей цифр любой длины, однако при этом следует иметь в виду, что при достаточно длинных числах вероятно появление одновременно нескольких искажений данных. Некоторые из таких ошибок могут привести к ошибочному выводу, что контрольное число, вычисленное по алгоритму Луна, подтверждает неизменность данных.

### Примеры:

***java***

```sh
import java.util.*;
import java.lang.String;

public class Main {

  public static void main(String[] args) {

       Scanner scan = new Scanner(System.in);
 
       System.out.print("Enter the number: ");
 
       String value = scan.next();
 
       int sum1 = 0; int sum2=0;
 
       final  int nDigits = value.length();
 
       for (int i = nDigits; i> 0; i--){
 
           int digit = Character.getNumericValue(value.charAt(i-1));
 
           int z=digit;int y=digit;
 
           if (i % 2 == 0){
 
               z *= 2;
 
               if (z > 9) {
 
                   z -= 9;
 
               }
 
               sum1 += z;
 
           }
 
           else  sum2 += y;           
 
       }
 
       int sum=sum1+sum2;
 
       if (value.length()!=16) sum=1;
 
       System.out.println(sum);
 
       if (sum%10 == 0){
 
           System.out.println ("Card Valid");
 
       } else {
 
           System.out.println("Card not Valid");
 
       }
  }
}
```

***c++***

```sh
#include <string>

int luhn(std::string input)
{
int number = 0;
int check_digit = 0;

    for(int i = 0; i < input.length(); i++)
    {
        number = input[i-1] - '0';
 
        if((i-1) % 2 != 0)
        {
            number *= 2;
 
            if(number > 9)
            {
                number -= 9;
            }
        }
 
        check_digit += number;
    }
 
    return (check_digit * 9) % 10;
}
```

***python***

```sh
from functools import reduce

def luhn(code):
# Предварительно рассчитанные результаты умножения на 2 с вычетом 9 для больших цифр
# Номер индекса равен числу, над которым проводится операция
LOOKUP = (0, 2, 4, 6, 8, 1, 3, 5, 7, 9)
code = reduce(str.__add__, filter(str.isdigit, code))
evens = sum(int(i) for i in code[-1::-2])
odds = sum(LOOKUP[int(i)] for i in code[-2::-2])
return ((evens + odds) % 10 == 0)

print("Прошел проверку: ", luhn('4561 2612 1234 5467'))
print("Не прошел проверку: ", luhn('4561 2612 1234 5464'))
javaScript
function luhnAlgorithm(value) {

value = value.replace(/\D/g, '');

var nCheck = 0;

var bEven = false;

for (var n = value.length - 1; n >= 0; n--) {

       var nDigit = parseInt(value.charAt(n), 10);
 
 
 
       if (bEven && (nDigit *= 2) > 9) {
 
           nDigit -= 9;
 
       }
 
 
 
       nCheck += nDigit;
 
       bEven = !bEven;

}
return (nCheck % 10) == 0;
}

// Вариант покороче

const Moon_Algorithm = setValue => {

       let ch = 0;
 
       const num = String(setValue).replace(/\D/g, '');
 
       const isOdd = num.length % 2 !== 0;
 
 
 
       if ('' === num) return false;
 
 
 
       for (let i = 0; i < num.length; i++) {
 
           let n = parseInt(num[i], 10);
 
 
 
           ch += (isOdd | 0) === (i % 2) && 9 < (n *= 2) ? (n - 9) : n;
 
       }
 
 
 
       return 0 === (ch % 10);

}
```

***C***

```sh
#include <stdbool.h> // для типа bool
#include <string.h> // для strlen()

bool checkLuhn(const char* card_number) // принимаем в аргументы номер карты
{
int len = strlen(card_number);      // узнаем длину номера карты
int number = 0;                     // текущая цифра в цикле (см. ниже)
int sum = 0;                        // переменная которая будет хранить проверочную сумму цифр

    for(int i = 0; i < len; i++)        // главный цикл, в процессе которого проверяется валидность номера карты
    {
        number = card_number[i] - '0';  // переводим цифру из char в int
 
        if(i % 2 == 0)                  // если позиция цифры чётное, то:
        {
            number *= 2;                // умножаем цифру на 2
 
            if(number > 9)              // согласно алгоритму, ни одно число не должно быть больше 9
            {
                number -= 9;            // второй вариант сведения к единичному разряду
            }
        }
 
        sum += number;                  // прибавляем к sum номера согласно алгоритму
    }
 
    if(sum % 10 == 0)                   // если проверочная сумма чётно делится на 10, то:
    {
        return true;                    // номер карты введён верно!
    }
    else                                // в любом другом случае:
    {
        return false;                   // при введении номера карты была допущена ошибка
    }
}
```

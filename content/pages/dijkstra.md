---
title: Алгоритм Дейкстры 
permalink: /article/dijkstra/index.html
---

### Область применения:

Алгоритм применим к графам и находит кратчайшие пути от одной из вершин графа до всех остальных. Работает только для графов без ребер отрицательного веса. Алгоритм Дейкстры широко применяется в программировании и технологияых, например, его используют протоколы маршрутизации OSPF и IS-IS. 

### Историческая справка и информация об авторах:

Алгоритм Дейкстры назван в честь голландского ученого Эдсгера Дейкстры. Алгоритм был предложен в 1959 году для нахождения кратчайших путей от одной вершины до всех остальных в ориентированном взвешенном графе, при условии, что все ребра в графе имеют неотрицательные веса.

### Идея (рисунки / анимации / видео):

Дан взвешенный ориентированный граф G(V,E) без дуг отрицательного веса. Найти кратчайшие пути от некоторой вершины a графа G до всех остальных вершин этого графа.

Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a.
Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки.
Работа алгоритма завершается, когда все вершины посещены

#### Инициализация 

Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности.
Это отражает то, что расстояния от a до других вершин пока неизвестны.
Все вершины графа помечаются как непосещённые.

#### Шаг алгоритма

Если все вершины посещены, алгоритм завершается.
В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку.
Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.
Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

### Блок-схема / Псевдокод 

```sh
func dijkstra(s):
    for v ∈ V            
        d[v] = ∞
        used[v] = false
    d[s] = 0
    for i ∈ V
        v = null
        for j ∈ V
            if !used[j] and (v == null or d[j] < d[v])
                v = j
        if d[v] == ∞
            break
        used[v] = true
        for e : исходящие из v рёбра    
            if d[v] + e.len < d[e.to]
                d[e.to] = d[v] + e.len
```

#### Описание

В простейшей реализации для хранения чисел d[i] можно использовать массив чисел, а для хранения принадлежности элемента множеству U — массив булевых переменных.
В начале алгоритма расстояние для начальной вершины полагается равным нулю, а все остальные расстояния заполняются большим положительным числом (бо́льшим максимального возможного пути в графе). Массив флагов заполняется нулями. Затем запускается основной цикл.
На каждом шаге цикла мы ищем вершину v с минимальным расстоянием и флагом равным нулю. Затем мы устанавливаем в ней флаг в 1 и проверяем все соседние с ней вершины u. Если в них (в u) расстояние больше, чем сумма расстояния до текущей вершины и длины ребра, то уменьшаем его. Цикл завершается, когда флаги всех вершин становятся равны 1, либо когда у всех вершин c флагом 0 d[i] = ∞ . Последний случай возможен тогда и только тогда, когда граф G несвязный.

### Реализации на разных языках:
#### Python

```sh
INF = 10 ** 10
dist = [INF] * n
 dist[start] = 0
used = [False] * n
min_dist = 0
min_vertex = start
 while min_dist < INF:
    i = min_vertex 
    used[i] = True 
    for j in range(n): 
        if dist[i] + w[i][j] < dist[j]: 
            dist[j] = dist[i] + w[i][j] 
    min_dist = INF
    for j in range(n):
        if not used[j] and dist[j] < min_dist:
            min_dist = dist[j]
            min_vertex = j
  ```

#### C++

```sh
const int INF = 1000000000;
vector <int> dist(n, INF);
dist[start] = 0;
vector <bool> used(n);
int min_dist = 0;
int min_vertex = start;
while (min_dist < INF)
{
    int i = min_vertex;
    used[i] = true;
    for (int j = 0; j < n; ++j)
        if (dist[i] + w[i][j] < dist[j])
                dist[j] = dist[i] + w[i][j];
    min_dist = INF;
    for (int j = 0; j < n; ++j)
        if (!used[j] && dist[j] < min_dist)
        {
            min_dist = dist[j];
            min_vertex = j;
        }
  }
```

#### Java

```sh
int INF = Integer.MAX_VALUE / 2; 
int vNum; 
int[][] graph;

void dijkstra(int start) {
    boolean[] used = new boolean [vNum]; 
    int[] dist = new int [vNum];   

    fill(dist, INF); 
    dist[start] = 0; 

    for (;;) {
        int v = -1;
        for (int nv = 0; nv < vNum; nv++) // перебираем вершины
            if (!used[nv] && dist[nv] < INF && (v == -1 || dist[v] > dist[nv])) // выбираем самую близкую непомеченную вершину
                     v = nv;
        if (v == -1) break; // ближайшая вершина не найдена
        used[v] = true; // помечаем ее
        for (int nv = 0; nv < vNum; nv++)
            if (!used[nv] && graph[v][nv] < INF) // для всех непомеченных смежных
                     dist[nv] = min(dist[nv], dist[v] + graph[v][nv]); // улучшаем оценку расстояния (релаксация)
    }
}
  ```

### Список источников:

 1. Dijkstra E. W. "A note on two problems in connexion with graphs" (англ.) 
 2. Левитин А. В. "Алгоритмы. Введение в разработку и анализ" 
 3. Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. "Алгоритмы. Построение и анализ"
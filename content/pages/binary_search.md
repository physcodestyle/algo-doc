title: Алгоритм Дейкстры 
permalink: /article/dijkstra/index.html
---

## Область применения

Бинарный поиск (также его синонимы: двоичный поиск, метод деления пополам, метод половинного деления, дихотомия) может быть использован для быстрого доступа к упорядоченным данным при ограниченном пространстве памяти. Иными словами, это классический алгоритм для поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины. Применяется в информатике, вычислительной математике и математическом программировании. Алгоритм имеет широкое распространение в информатике применительно к поиску в структурах данных, также бинарный поиск используют в качестве численного метода для нахождения приближённого решения уравнений и для нахождения экстремума целевой функции.

## Историческая справка и информация об авторах

Точно неизвестно, когда и при каких обстоятельствах бинарный поиск впервые появился. Однако известно, что он неоднократно упоминался в книгах о численных методах задач нелинейного программирования, а его код одним из первых написал некий ученый Йон Бентли.

## Идея (рисунки / анимации / видео)

Алгоритм используется в качестве быстрого варианта поиска в заранее отсортированном массиве. Получил распространение благодаря как наименьшей из возможных высоте алгоритма, так и из-за ряда своих вычислительных характеристик, а также (в среде нечисленных алгоритмов) из-за своей рекурсивности, то есть лёгкости записи. 
 Основная идея заключается в дроблении массива на половины и дальнейшем рекурсивном поиске в одной из них.


### Математическое описание алгоритма
Исходные данные: одномерный массив n чисел x(i) (где i - индекс; i = 0, ..., n - 1) упорядоченный по возрастанию (точнее — неубыванию) или убыванию (точнее — невозрастанию), а также число A, которое нужно найти в этом массиве. 
Вычисляемые данные: индекс (номер позиции) элемента, равного искомому (или ответ, что такого элемента нет).
Формулы метода: элементы на каждом этапе алгоритма рассматриваются в виде непрерывного отрезка массива. В каждой из пар находится сумма составляющих её элементов. На следующем этапе на пары разбиваются уже эти суммы (и те элементы, которые не вошли в уже вычисленные суммы), и т. д. Единственное вычисление, которое производится на каждой итерации метода — вычисление среднего арифметического левого и правого индексов. m(k) вычисляется как сумма l(k) c r(k), деленная пополам. Здесь и далее l(k), r(k), m(k) обозначаются индексы левого конца, правого конца и середины рассматриваемого отрезка массива на k-ой итерации. Сначала поиск производится по всему массиву, поэтому l(0) = 0, r(0) = n - 1. 


## Блок-схема / Псевдокод 

```sh
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = -1                      // l, r — левая и правая границы
    int r = len(a)    
    while l < r - 1                // Запускаем цикл
        m = (l + r) / 2            // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```

Инвариант цикла: правый индекс не меньше искомого элемента, а левый — строго меньше (т.к значение m присваевается левой границе l, только тогда, когда a[m] строго меньше искомого элемента key), тогда если r = l + 1 (что эквивалентно r − l = 1), то понятно, что r — самое левое вхождение искомого элемента (так как предыдущие элементы уже меньше искомого элемента)

## Реализации на разных языках

### Python

```sh
public int binarySearch(int[] sortedArray, int key, int low, int high) {
    int index = -1;

    while (low <= high) {
        int mid = (low + high) / 2;
        if (sortedArray[mid] < key) {
            low = mid + 1;
        } else if (sortedArray[mid] > key) {
            high = mid - 1;
        } else if (sortedArray[mid] == key) {
            index = mid;
            break;
        }
    }
    return index;
}
```

### C++

```sh
#include <iostream>
#include <set>
#include <climits>
using namespace std;
 
int inf = INT_MAX;
 
int main() {
    cin.sync_with_stdio(false);
    int n;
    cin >> n;
    int na;
    cin >> na;
    multiset<pair<int, int> > s;
    int a[na];
    int resa[n];
    for(int i=0; i<na; i++)
    {
        cin >> a[i];
        s.insert({a[i], a[i]});
    }
    for(int i=0; i<n; i++)
    {
        auto it=s.begin();
        int val=it->first;
        int t=it->second;
        s.erase(it);
        s.insert({val+t, t});
        resa[i]=val;
    }
    int nb;
    cin >> nb;
    int b[nb];
    for(int i=0; i<nb; i++)
    {
        cin >> b[i];
    }
    multiset<pair<int, int> > q;
    long long l=resa[n-1], r=10000100;
    while(l<r)
    {
        int w=0;
        int m=(l+r)/2;
        for(int i=0; i<nb; i++)
        {
            q.insert({b[i], b[i]});
        }
        q.insert({inf, inf});
        for(int i=n-1; i>=0; i--)
        {
            int y=m-resa[i];
            auto x=q.begin();
            if(y<(x->first))
            {
                w++;
                break;
            }
            else{
                auto it=q.lower_bound({y, -1});
                int z=it->first;
                if(z>y)
                    it--;
                int val=it->first;
                int t=it->second;
                q.erase(it);
                q.insert({val+t, t});
            }
        }
        if(w==0)
            r=m;
        else
            l=m+1;
        q.clear();  
    }
    cout << l;
    return 0;
}
```

### Java

```sh
const createCounter = (c) => () => c++

function getGuess(low, high) {
  return (low + high) / 2
}

function abs(n) {
  return n < 0 ? n * -1 : n
}

function powSqua(n) {
  return n * n
}

function sqrt(n) {
/*
Так как дробные числа всегда имеют
погрешность, это надо учитывать;
а также чем больше epsilon,
тем веротянее меньше будет итераций,
на мелком дроблении
*/
const epsilon = 0.01
let low = 0
let high = n
let guess = getGuess(low, high)
let squaGuess = powSqua(guess)
const counter = createCounter(1)
while (abs(squaGuess - n) >= epsilon) {
    if (squaGuess > n) {
      high = guess
    } else {
      low = guess
    }

guess = getGuess(low, high)
quaGuess = powSqua(guess)
counter()
    }
console.log(`iteractions count ${counter() - 1}`)
return guess
}
```

### JavaScript

```sh
function BinarySearch(t,A)       // t - искомый элемент,
{                                // A - упорядоченный массив, в котором ищем.
    var i = 0, j = A.length, k; 
                                 
    while (i < j)                
    {  k = Math.floor((i+j)/2);
       if (t <= A[k]) j = k;
       else i = k+1;
    }
   
    if (A[ i ] === t) return i;     // На выходе индекс искомого элемента.
    else return -1;                 // Если искомого элемента нет в массиве, то -1.
}
```

## Список источников:

1. Левитин А.В. "Алгоритмы. Введение в разработку и анализ."
2. Амосов А. А., Дубинский Ю. А., Копченова Н. П. "Вычислительные методы для инженеров"
3. Бахвалов Н. С., Жидков Н. П., Кобельков Г. Г. "Численные методы"
4. Волков Е. А. "Численные методы"
5. Гилл Ф., Мюррей У., Райт М. "Практическая оптимизация"
6. Корн Г., Корн Т. "Справочник по математике для научных работников и инженеров"
7. Максимов Ю. А., Филлиповская Е. А. "Алгоритмы решения задач нелинейного программирования"